/**
 * Test Utilities
 * 
 * Helper functions for testing:
 * - Factory functions for creating test data
 * - Common test assertions
 * - Mock data generators
 */

import mongoose from 'mongoose';
import bcrypt from 'bcryptjs';
import { IProduct } from '@/models/Product';
import { IUser } from '@/models/User';
import { IOrder } from '@/models/Order';
import { ICart } from '@/models/Cart';
import { ICategory } from '@/models/Category';
import { IInventoryLog } from '@/models/InventoryLog';
import { ISiteSettings } from '@/models/SiteSettings';

/**
 * Generate random string
 */
export function randomString(length: number = 10): string {
  return Math.random().toString(36).substring(2, length + 2);
}

/**
 * Generate random email
 */
export function randomEmail(): string {
  return `test-${randomString()}@example.com`;
}

/**
 * Generate random mobile number
 */
export function randomMobile(): string {
  return Math.floor(1000000000 + Math.random() * 9000000000).toString();
}

/**
 * Generate random ObjectId
 */
export function randomObjectId(): mongoose.Types.ObjectId {
  return new mongoose.Types.ObjectId();
}

/**
 * Create test product data
 */
export function createTestProduct(overrides: Partial<IProduct> = {}): Partial<IProduct> {
  return {
    slug: `test-product-${randomString()}`,
    title: `Test Product ${randomString()}`,
    description: 'Test product description',
    shortDescription: 'Short description',
    sku: `SKU-${randomString().toUpperCase()}`,
    price: 1000,
    currency: 'INR',
    category: 'rings',
    material: 'Gold',
    images: ['https://example.com/image.jpg'],
    primaryImage: 'https://example.com/image.jpg',
    alt: 'Test product image',
    status: 'active',
    inventory: {
      quantity: 10,
      reservedQuantity: 0,
      lowStockThreshold: 5,
      trackQuantity: true,
      allowBackorder: false,
      location: 'warehouse-1',
    },
    featured: false,
    mostLoved: false,
    ...overrides,
  };
}

/**
 * Create test user data
 */
export function createTestUser(overrides: Partial<IUser> = {}): Partial<IUser> {
  return {
    email: randomEmail(),
    firstName: 'Test',
    lastName: 'User',
    password: 'Test@123456',
    role: 'customer',
    isActive: true,
    emailVerified: false,
    ...overrides,
  };
}

/**
 * Create test category data
 * Note: This returns data that can be used with Category.create()
 * All required fields (name, slug, displayName, image, alt) are included
 */
export function createTestCategory(overrides: Partial<ICategory> = {}): Partial<ICategory> {
  const baseName = `Test Category ${randomString()}`;
  return {
    name: baseName,
    slug: `test-category-${randomString()}`,
    displayName: baseName,
    description: 'Test category description',
    image: 'https://example.com/category.jpg',
    alt: 'Test category image',
    active: true,
    ...overrides,
  };
}

/**
 * Helper to create a test category in the database
 * Use this in tests instead of Category.create() directly
 */
export async function createTestCategoryInDb(overrides: Partial<ICategory> = {}): Promise<ICategory> {
  const Category = (await import('@/models/Category')).default;
  return await Category.create(createTestCategory(overrides));
}

/**
 * Create test order data
 */
export function createTestOrder(overrides: Partial<IOrder> = {}): Partial<IOrder> {
  return {
    userId: randomObjectId(),
    status: 'pending',
    paymentStatus: 'pending',
    items: [
      {
        productId: randomObjectId(),
        productSku: `SKU-${randomString()}`,
        productTitle: 'Test Product',
        image: 'https://example.com/image.jpg', // Required field
        quantity: 1,
        price: 1000,
        total: 1000,
      },
    ],
    subtotal: 1000,
    tax: 0,
    shipping: 0,
    discount: 0,
    total: 1000,
    currency: 'INR',
    paymentMethod: 'cod',
    shippingAddress: {
      firstName: 'Test',
      lastName: 'User',
      addressLine1: '123 Test St',
      city: 'Test City',
      state: 'Test State',
      zipCode: '12345',
      country: 'India',
      phone: '9876543210',
      countryCode: '+91',
    },
    billingAddress: {
      firstName: 'Test',
      lastName: 'User',
      addressLine1: '123 Test St',
      city: 'Test City',
      state: 'Test State',
      zipCode: '12345',
      country: 'India',
      phone: '9876543210',
      countryCode: '+91',
    },
    // orderNumber will be auto-generated by pre-save hook
    ...overrides,
  };
}

/**
 * Create test cart data
 */
export function createTestCart(overrides: Partial<ICart> = {}): Partial<ICart> {
  return {
    userId: randomObjectId(),
    items: [
      {
        productId: randomObjectId(),
        sku: `SKU-${randomString()}`,
        title: 'Test Product',
        image: 'https://example.com/image.jpg',
        price: 1000,
        quantity: 1,
        subtotal: 1000,
      },
    ],
    subtotal: 1000,
    tax: 0,
    shipping: 0,
    discount: 0,
    total: 1000,
    currency: 'INR',
    ...overrides,
  };
}

/**
 * Create test inventory log data
 */
export function createTestInventoryLog(overrides: Partial<IInventoryLog> = {}): Partial<IInventoryLog> {
  return {
    productId: randomObjectId(),
    productSku: `SKU-${randomString()}`,
    productTitle: 'Test Product',
    type: 'sale',
    quantity: 1,
    previousQuantity: 10,
    newQuantity: 9,
    reason: 'Order sale',
    performedBy: {
      type: 'system',
      name: 'Test System',
    },
    ...overrides,
  };
}

/**
 * Create test site settings data
 */
export function createTestSiteSettings(overrides: Partial<ISiteSettings> = {}): Partial<ISiteSettings> {
  return {
    type: 'general',
    data: {
      siteName: 'Test Site',
      siteDescription: 'Test site description',
      contactEmail: 'test@example.com',
      contactPhone: '+911234567890',
    },
    ...overrides,
  };
}

/**
 * Hash password for testing
 */
export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, 10);
}

/**
 * Compare password for testing
 */
export async function comparePassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

/**
 * Wait for async operations
 */
export function wait(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Assert error message contains text
 */
export function expectErrorContains(error: unknown, text: string): void {
  if (error instanceof Error) {
    if (!error.message.includes(text)) {
      throw new Error(`Expected error message to contain "${text}", but got: ${error.message}`);
    }
  } else {
    throw new Error('Expected error to be an Error instance');
  }
}
